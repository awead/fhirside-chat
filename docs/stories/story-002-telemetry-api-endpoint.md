# Story: Backend Telemetry API Endpoint

**Status:** Ready for Development
**Story ID:** STORY-002
**Epic:** Epic 002 - Front-End Chat Interface with Telemetry
**Priority:** High
**Estimated Effort:** 3-5 Story Points
**Dependencies:** None (foundational for Stories 003 and 004)

---

## Story

As a **developer building the front-end chat interface**,
I want **a REST API endpoint that exposes OpenTelemetry trace data for a given session**,
So that **I can display real-time telemetry information showing OpenAI API calls and Aidbox MCP queries in the UI**.

---

## Story Context

### Existing System Integration

- **Integrates with:** OpenTelemetry instrumentation (existing), Jaeger backend (localhost:16686), FastAPI app
- **Technology:** Python 3.13, FastAPI 0.115.0+, OpenTelemetry SDK 1.37.0+, Jaeger Query API
- **Follows pattern:** Existing async FastAPI endpoint pattern (see `/chat` and `/patient` endpoints in `src/app.py`)
- **Touch points:**
  - Existing OpenTelemetry `instrumentation()` in `src/ai/telemetry.py`
  - Jaeger backend at `http://localhost:16686` (Query API at port 16686)
  - FastAPI application in `src/app.py` (new endpoint added here)
  - CORS middleware (needs to be added to FastAPI app)

---

## Acceptance Criteria

### 1. Telemetry Data Models

**Functional Requirements:**
1. Create `TelemetryRequest` model accepting `session_id` parameter
2. Create `TelemetryResponse` model with structured trace/span data
3. Response includes spans filtered by session_id with relevant fields:
   - Span ID, trace ID, parent span ID
   - Operation name (e.g., "openai.chat.completion", "mcp.query")
   - Start time, end time, duration
   - Span attributes (OpenAI prompt/response, MCP queries, token counts)
   - Span status (OK, ERROR)
4. Models use Pydantic with proper validation and Field descriptions

**Integration Requirements:**
5. Models placed in `src/models/telemetry.py` following existing pattern
6. JSON serialization compatible with front-end consumption
7. No modifications to existing models

**Quality Requirements:**
8. Unit tests verify model validation and serialization
9. Type hints used throughout
10. Ruff linting passes

### 2. Jaeger Query Integration

**Functional Requirements:**
11. Implement Jaeger Query API client to fetch trace data
12. Query traces by custom attribute `session_id` (added to spans)
13. Parse Jaeger JSON response into Python objects
14. Filter spans to include only relevant operations (OpenAI, MCP)
15. Extract span attributes including:
    - OpenAI: prompts, completions, model, token counts
    - MCP: FHIR queries, resource types, response data

**Integration Requirements:**
16. Use `httpx` or `requests` for HTTP calls to Jaeger Query API
17. Handle Jaeger API errors gracefully (return empty list if service unavailable)
18. Query endpoint: `http://localhost:16686/api/traces?service=fhir-chat-agent&tag=session_id:{session_id}`

**Quality Requirements:**
19. Connection timeout configured (3-5 seconds max)
20. Error logging for Jaeger API failures
21. Unit tests mock Jaeger API responses

### 3. Telemetry API Endpoint

**Functional Requirements:**
22. Implement `GET /telemetry/{session_id}` endpoint in `src/app.py`
23. Endpoint returns `TelemetryResponse` with filtered trace data
24. Return 200 with data (even if empty list for no traces found)
25. Return 422 for invalid session_id format
26. Return 500 for Jaeger API or internal failures

**Integration Requirements:**
27. Follows existing async FastAPI endpoint pattern
28. Uses Pydantic models for request validation and response
29. Logging includes session_id context
30. OpenAPI schema auto-generated by FastAPI

**Quality Requirements:**
31. Integration tests cover success, empty response, and error scenarios
32. Endpoint response time < 1 second for typical session
33. No performance impact on existing `/chat` or `/patient` endpoints

### 4. CORS Configuration

**Functional Requirements:**
34. Add CORS middleware to FastAPI app for front-end access
35. Configure allowed origins for development (localhost:3000, localhost:5173)
36. Allow GET method for telemetry endpoint
37. Allow standard headers and credentials

**Integration Requirements:**
38. Use FastAPI's `CORSMiddleware` from `fastapi.middleware.cors`
39. Configuration added in `create_app()` function
40. Existing endpoints inherit CORS settings

**Quality Requirements:**
41. CORS headers present in OPTIONS and GET responses
42. Manual test with browser fetch() confirms CORS works
43. Documentation notes security consideration (localhost only for dev)

### 5. Session ID Instrumentation

**Functional Requirements:**
44. Modify existing agent spans to include `session_id` attribute
45. Extract session_id from request context and add to OpenTelemetry spans
46. Ensure all spans in a chat request chain include session_id

**Integration Requirements:**
47. Update `ChatService.process()` to propagate session_id to agent context
48. Modify `instrumentation()` or agent setup to include session_id in spans
49. No breaking changes to existing instrumentation

**Quality Requirements:**
50. Verify session_id appears in Jaeger UI for chat requests
51. Existing telemetry functionality unaffected
52. Manual E2E test confirms traces are queryable by session_id

### 6. System Integration & Regression Testing

**Integration Requirements:**
53. Existing `/chat` endpoint remains functional (regression test passes)
54. Existing `/patient` endpoint remains functional (regression test passes)
55. Jaeger continues to receive all traces as before
56. New endpoint coexists with existing endpoints

**Quality Requirements:**
57. All existing tests pass (no regressions)
58. New telemetry endpoint tests achieve 80%+ coverage
59. Manual E2E test: send chat message, query telemetry, verify data matches

---

## Technical Notes

### Integration Approach

**Jaeger Query API:**
- Query API documentation: https://www.jaegertracing.io/docs/latest/apis/#grpcprotobuf-stable
- REST API endpoint: `GET http://localhost:16686/api/traces`
- Query parameters:
  - `service`: "fhir-chat-agent"
  - `tag`: "session_id:{value}"
  - `limit`: 100 (default)
  - `lookback`: 1h (default)

**Session ID Propagation:**
- Option 1: Use OpenTelemetry Baggage to propagate session_id through context
- Option 2: Add session_id as span attribute in ChatService before calling agent
- Recommendation: Option 2 (simpler, more explicit)

**CORS Setup:**
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "OPTIONS"],
    allow_headers=["*"],
)
```

### Existing Pattern Reference

Follow the pattern in `src/app.py`:
- Async endpoint handlers with type-annotated parameters
- Pydantic models for request/response
- HTTPException for errors with appropriate status codes
- Logging with contextual information
- Try-except blocks for error handling

Example:
```python
@app.get("/telemetry/{session_id}", response_model=TelemetryResponse)
async def get_telemetry(session_id: str):
    try:
        # Query Jaeger API
        # Parse and filter spans
        # Return structured response
    except Exception as e:
        logger.error(f"telemetry_error", extra={"session_id": session_id, "error": str(e)})
        raise HTTPException(status_code=500, detail="Failed to retrieve telemetry data")
```

### Key Constraints

- **Security:** Telemetry data contains sensitive information (prompts, responses, FHIR data)
  - Only expose on localhost for development
  - Add authentication before production use
  - Document security considerations in README
- **Performance:** Jaeger queries should be fast, but add timeout to prevent blocking
- **Data Privacy:** Consider filtering PHI from trace attributes if present

---

## Definition of Done

- [x] Functional requirements met (telemetry models, Jaeger integration, API endpoint)
- [x] Integration requirements verified (CORS, session_id in spans, existing endpoints work)
- [x] Existing functionality regression tested (all tests pass)
- [x] Code follows existing patterns and standards (async, Pydantic, error handling)
- [x] Tests pass (existing and new) with 80%+ coverage for new code
- [x] Documentation updated (README notes security and telemetry endpoint usage)
- [x] Manual E2E test completed: send chat message, query /telemetry, verify spans visible

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Exposing sensitive telemetry data (OpenAI prompts/responses, FHIR queries) to front-end without authentication

**Mitigation:**
- Only bind telemetry endpoint to localhost (not 0.0.0.0)
- Add clear security warning in documentation
- Consider adding optional API key authentication for telemetry endpoint
- Filter out any PHI or sensitive attributes from span data

**Secondary Risk:** Jaeger Query API may be slow or unavailable, blocking telemetry requests

**Mitigation:**
- Add short timeout (3-5 seconds) for Jaeger HTTP calls
- Return empty telemetry response if Jaeger unavailable (don't fail hard)
- Log errors but don't break main chat functionality

**Rollback:** Remove `/telemetry` endpoint and CORS middleware; existing endpoints continue working

### Compatibility Verification

- [x] No breaking changes to existing APIs (`/chat`, `/patient`, `/ws`)
- [x] Database changes: None (no database used)
- [x] UI changes: N/A (backend only, front-end built in next stories)
- [x] Performance impact: Minimal (separate endpoint, no impact on chat path)

---

## Tasks

### Task 1: Create Telemetry Data Models
**Estimated Time:** 1 hour

#### Subtasks:
- [ ] Create `src/models/telemetry.py`
- [ ] Implement `TelemetryRequest` model (session_id field)
- [ ] Implement `SpanData` model (span_id, trace_id, operation_name, timestamps, attributes, status)
- [ ] Implement `TelemetryResponse` model (session_id, spans: List[SpanData], trace_count)
- [ ] Add proper type hints and Field descriptions
- [ ] Create `tests/models/test_telemetry.py`
- [ ] Write unit tests for model validation and serialization
- [ ] Run tests and verify pass
- [ ] Run ruff linting

### Task 2: Implement Jaeger Query Client
**Estimated Time:** 2 hours

#### Subtasks:
- [ ] Create `src/telemetry/jaeger_client.py` (new directory)
- [ ] Implement `async def query_traces_by_session(session_id: str) -> List[SpanData]`
- [ ] Use `httpx.AsyncClient` for Jaeger Query API HTTP calls
- [ ] Parse Jaeger JSON response format
- [ ] Filter spans by operation name (include OpenAI and MCP spans)
- [ ] Extract relevant span attributes (prompts, responses, queries)
- [ ] Add error handling and logging
- [ ] Add connection timeout (5 seconds)
- [ ] Create `tests/telemetry/test_jaeger_client.py`
- [ ] Write unit tests mocking Jaeger API responses
- [ ] Test error scenarios (timeout, API unavailable)

### Task 3: Add Session ID to Spans
**Estimated Time:** 1 hour

#### Subtasks:
- [ ] Modify `ChatService.process()` in `src/app.py`
- [ ] Add session_id as span attribute using OpenTelemetry API
- [ ] Update agent initialization to accept/propagate session_id context
- [ ] Verify session_id appears in spans via manual Jaeger UI check
- [ ] Update existing chat endpoint tests to verify no breakage
- [ ] Document session_id propagation approach

### Task 4: Implement Telemetry API Endpoint
**Estimated Time:** 1.5 hours

#### Subtasks:
- [ ] Add `GET /telemetry/{session_id}` endpoint to `src/app.py`
- [ ] Import telemetry models and Jaeger client
- [ ] Implement endpoint handler calling Jaeger client
- [ ] Add error handling (422 for invalid input, 500 for failures)
- [ ] Add logging with session_id context
- [ ] Create `tests/test_telemetry_endpoint.py` (or add to `tests/test_app.py`)
- [ ] Write integration tests mocking Jaeger client
- [ ] Test success case (traces returned)
- [ ] Test empty case (no traces found)
- [ ] Test error case (Jaeger unavailable)

### Task 5: Add CORS Middleware
**Estimated Time:** 30 minutes

#### Subtasks:
- [ ] Import `CORSMiddleware` from `fastapi.middleware.cors`
- [ ] Add CORS middleware to `create_app()` function
- [ ] Configure allowed origins: localhost:3000, localhost:5173
- [ ] Configure allowed methods: GET, POST, OPTIONS
- [ ] Manual test with browser: `fetch('http://localhost:8000/telemetry/test-session')`
- [ ] Verify CORS headers present in response
- [ ] Update README with CORS notes

### Task 6: Documentation and E2E Testing
**Estimated Time:** 1 hour

#### Subtasks:
- [ ] Update README.md with telemetry endpoint usage
- [ ] Add security warning about sensitive data exposure
- [ ] Document CORS configuration
- [ ] Add example curl command for telemetry endpoint
- [ ] Perform manual E2E test:
  1. Start services (docker compose up, uvicorn)
  2. Send chat message via `/chat` endpoint
  3. Query `/telemetry/{session_id}` endpoint
  4. Verify spans returned with OpenAI and MCP data
  5. Check Jaeger UI to confirm session_id visible
- [ ] Verify all existing tests pass
- [ ] Verify no regression in `/chat` or `/patient` endpoints

---

## Implementation Checkpoints

1. **After models:** Verify JSON serialization works, types are correct
2. **After Jaeger client:** Test with real Jaeger instance, verify span parsing
3. **After session_id instrumentation:** Check Jaeger UI to confirm session_id in spans
4. **After endpoint:** Test with mocked Jaeger client first, then real integration
5. **After CORS:** Test with browser fetch() to confirm headers work
6. **Final:** E2E test with complete flow (chat → telemetry query → verify data)

---

## Dependencies and Sequencing

**Depends on:**
- None (foundational story)

**Blocks:**
- Story 3: Chat UI Component (needs this endpoint to function)
- Story 4: Telemetry Visualization Panel (needs this endpoint for data)

**Development Order:**
1. Models first (foundation)
2. Session ID instrumentation (enables querying)
3. Jaeger client (data retrieval)
4. API endpoint (exposes data)
5. CORS (enables front-end access)
6. Documentation and testing (validation)

---

## Success Metrics

- Telemetry endpoint responds in < 1 second for typical session
- Spans include both OpenAI and MCP operations
- Session ID successfully filters traces in Jaeger
- CORS headers allow front-end requests from localhost dev servers
- Zero impact on existing endpoint performance
- All tests pass with 80%+ coverage for new code
